# StoryForge MVP Scaffold Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Scaffold the full StoryForge MVP monorepo with a running Vite + React frontend, Convex backend with complete schema, WorkOS auth, stubbed integrations, and a Gradient ADK agent skeleton.

**Architecture:** Monorepo with three workspaces: `app/` (Vite + React + Tailwind + shadcn/ui), `convex/` (Convex backend at repo root), `agents/` (Python Gradient ADK). Frontend talks to Convex for all data. Convex actions call external APIs and deployed agents. Auth via WorkOS AuthKit with first-party Convex integration.

**Tech Stack:** React 19, Vite, Tailwind CSS, shadcn/ui, Convex, WorkOS AuthKit, React Router v7, Python 3.10+, Gradient ADK, LangGraph

---

## Task 1: Initialize Vite + React + TypeScript Project

**Files:**
- Create: `app/package.json`
- Create: `app/vite.config.ts`
- Create: `app/tsconfig.json`
- Create: `app/tsconfig.app.json`
- Create: `app/index.html`
- Create: `app/src/main.tsx`
- Create: `app/src/App.tsx`
- Create: `app/src/vite-env.d.ts`

**Step 1: Create the Vite project**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
npm create vite@latest app -- --template react-ts
```

Accept defaults. This creates the `app/` directory with React + TypeScript template.

**Step 2: Install dependencies**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npm install
```

**Step 3: Verify it runs**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx vite --port 5173 &
sleep 3
curl -s http://localhost:5173 | head -5
kill %1
```

Expected: HTML response with `<div id="root">`.

**Step 4: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add app/
git commit -m "feat: initialize Vite + React + TypeScript project"
```

---

## Task 2: Add Tailwind CSS + shadcn/ui

**Files:**
- Modify: `app/package.json` (add dependencies)
- Modify: `app/vite.config.ts` (add Tailwind plugin)
- Create: `app/src/index.css` (Tailwind directives)
- Create: `app/components.json` (shadcn config)
- Modify: `app/tsconfig.json` (path aliases)
- Modify: `app/tsconfig.app.json` (path aliases)

**Step 1: Install Tailwind CSS v4 + Vite plugin**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npm install -D tailwindcss @tailwindcss/vite
```

**Step 2: Add Tailwind plugin to vite.config.ts**

Replace `app/vite.config.ts` with:

```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import path from "path";

export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
```

**Step 3: Set up Tailwind CSS entry**

Replace `app/src/index.css` with:

```css
@import "tailwindcss";
```

Make sure `app/src/main.tsx` imports `./index.css`.

**Step 4: Configure TypeScript path aliases**

In `app/tsconfig.json`, add inside `compilerOptions`:

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

Do the same in `app/tsconfig.app.json`.

**Step 5: Initialize shadcn/ui**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx shadcn@latest init -d
```

This creates `components.json` and sets up the `src/components/ui/` directory.

**Step 6: Add core shadcn components we'll need**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx shadcn@latest add button card tabs badge separator popover sonner avatar dropdown-menu input textarea label select slider dialog sheet scroll-area tooltip
```

**Step 7: Verify Tailwind works**

Replace `app/src/App.tsx` with:

```tsx
function App() {
  return (
    <div className="flex items-center justify-center min-h-screen bg-zinc-950 text-white">
      <h1 className="text-4xl font-bold">StoryForge</h1>
    </div>
  );
}

export default App;
```

Run: `cd app && npx vite --port 5173` — verify the page renders with styled text.

**Step 8: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add app/
git commit -m "feat: add Tailwind CSS v4 and shadcn/ui with core components"
```

---

## Task 3: Initialize Convex Backend + Schema

**Files:**
- Create: `convex/schema.ts`
- Create: `convex/tsconfig.json`
- Create: `convex/_generated/` (auto-generated by Convex)
- Modify: `app/package.json` (add convex dependency)

**Step 1: Install Convex in the app**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npm install convex
```

**Step 2: Initialize Convex**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx convex init
```

This creates the `convex/` directory at `app/convex/`. We need to move it to the repo root per our design. However, Convex expects `convex/` relative to where `package.json` is. Since our `package.json` is in `app/`, Convex will look for `app/convex/`. This is fine — update the design: Convex lives at `app/convex/` not repo root.

Actually, the better approach: keep convex at the root level and configure Convex to find it. Let me adjust.

Alternative: Run `npx convex init` from the repo root and install convex there too. But this creates a split — app dependencies in `app/package.json`, convex dependency at root.

**Simplest approach:** Keep everything in `app/`. Convex goes to `app/convex/`. The monorepo structure becomes:

```
storyforge/
├── app/
│   ├── convex/          # Convex backend lives here
│   ├── src/             # React frontend
│   ├── package.json     # All JS dependencies
│   └── ...
├── agents/              # Python (separate)
└── docs/
```

This is cleaner. One `package.json`, one `node_modules`, Convex finds its config naturally.

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx convex dev --once
```

Note: `npx convex dev` will prompt to create a new project. Create it with name "storyforge". The `--once` flag runs codegen once and exits.

**Step 3: Write the full Convex schema**

Create `app/convex/schema.ts`:

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  users: defineTable({
    workosUserId: v.string(),
    name: v.string(),
    email: v.string(),
    role: v.string(), // "admin" | "producer" | "dj" | "contributor"
    stations: v.array(v.string()),
    styleProfileId: v.optional(v.id("styleProfiles")),
    avatarUrl: v.optional(v.string()),
    lastActiveAt: v.optional(v.number()),
    notificationPrefs: v.optional(v.any()),
  })
    .index("by_workos_id", ["workosUserId"])
    .index("by_email", ["email"]),

  stations: defineTable({
    slug: v.string(),
    name: v.string(),
    description: v.string(),
    voiceGuide: v.string(),
    systemPrompt: v.string(),
  }).index("by_slug", ["slug"]),

  stories: defineTable({
    title: v.string(),
    stationId: v.string(),
    creatorId: v.id("users"),
    status: v.string(),

    // Audio
    audioFileId: v.optional(v.id("_storage")),
    audioDurationSeconds: v.optional(v.number()),
    editedAudioFileId: v.optional(v.id("_storage")),
    previewAudioFileId: v.optional(v.id("_storage")),

    // Transcript reference
    transcriptId: v.optional(v.id("transcripts")),

    // Production state
    editOperations: v.optional(v.any()),
    assemblyState: v.optional(v.any()),
    generatedScript: v.optional(v.any()),

    // DJ steering
    selectedAngle: v.optional(v.string()),
    themes: v.optional(v.array(v.string())),
    emotionalTone: v.optional(v.string()),
    mustIncludeQuotes: v.optional(v.any()),
    excludeRanges: v.optional(v.any()),
    narrativeDirection: v.optional(v.string()),
    additionalContext: v.optional(v.string()),
    targetLengthSeconds: v.optional(v.number()),
    format: v.optional(v.string()),

    // Generated content
    airBreak: v.optional(v.any()),
    podcastSegment: v.optional(v.any()),
    socialThread: v.optional(v.any()),
    webArticle: v.optional(v.any()),
    newsletterCopy: v.optional(v.any()),
    pressRelease: v.optional(v.any()),

    // Sound design
    soundAssets: v.optional(
      v.array(
        v.object({
          id: v.string(),
          name: v.string(),
          source: v.string(),
          fileId: v.id("_storage"),
          type: v.string(),
          prompt: v.optional(v.string()),
          freesoundId: v.optional(v.number()),
          license: v.optional(v.string()),
          attribution: v.optional(v.string()),
          durationSeconds: v.number(),
          waveformTrack: v.optional(v.number()),
        })
      )
    ),

    // Approval checkpoints
    transcriptApprovedAt: v.optional(v.number()),
    tapeApprovedAt: v.optional(v.number()),
    assemblyApprovedAt: v.optional(v.number()),
    scriptsApprovedAt: v.optional(v.number()),
    producerApprovedAt: v.optional(v.number()),
    producerApprovedBy: v.optional(v.id("users")),

    // Workflow
    assignedProducerId: v.optional(v.id("users")),
    scheduledDate: v.optional(v.number()),
    publishedDate: v.optional(v.number()),
  })
    .index("by_station", ["stationId"])
    .index("by_creator", ["creatorId"])
    .index("by_status", ["status"])
    .index("by_station_status", ["stationId", "status"]),

  transcripts: defineTable({
    storyId: v.id("stories"),
    rawSttJson: v.any(),
    markdown: v.string(),
    speakers: v.any(),
    durationSeconds: v.number(),
    wordTimestamps: v.any(),
    fillerWords: v.optional(v.any()),
    storyAngles: v.optional(v.any()),
    keyQuotes: v.optional(v.any()),
    emotionalArc: v.optional(v.any()),
    corrections: v.optional(v.any()),
    offRecordRanges: v.optional(v.any()),
    searchableText: v.string(),
  })
    .index("by_story", ["storyId"])
    .searchIndex("search_text", { searchField: "searchableText" }),

  styleProfiles: defineTable({
    userId: v.id("users"),
    samples: v.any(),
    analysis: v.any(),
  }).index("by_user", ["userId"]),

  comments: defineTable({
    storyId: v.id("stories"),
    userId: v.id("users"),
    type: v.string(),
    content: v.string(),
    scriptBlockIndex: v.optional(v.number()),
    scriptLineText: v.optional(v.string()),
    audioTimestampStart: v.optional(v.float64()),
    audioTimestampEnd: v.optional(v.float64()),
    originalText: v.optional(v.string()),
    editedText: v.optional(v.string()),
    status: v.string(),
    resolvedBy: v.optional(v.id("users")),
    resolvedAt: v.optional(v.number()),
    parentCommentId: v.optional(v.id("comments")),
    isProducerNote: v.boolean(),
    blocksProgress: v.boolean(),
    createdAt: v.number(),
  })
    .index("by_story", ["storyId"])
    .index("by_story_status", ["storyId", "status"])
    .index("by_parent", ["parentCommentId"]),

  notifications: defineTable({
    userId: v.id("users"),
    type: v.string(),
    storyId: v.optional(v.id("stories")),
    triggeredBy: v.optional(v.id("users")),
    message: v.string(),
    detail: v.optional(v.string()),
    deepLink: v.optional(v.any()),
    read: v.boolean(),
    emailSent: v.boolean(),
    createdAt: v.number(),
  })
    .index("by_user_unread", ["userId", "read"])
    .index("by_user_time", ["userId", "createdAt"]),

  narrationTakes: defineTable({
    storyId: v.id("stories"),
    blockIndex: v.number(),
    takeNumber: v.number(),
    audioFileId: v.id("_storage"),
    durationSeconds: v.number(),
    isSelected: v.boolean(),
    recordedBy: v.id("users"),
  })
    .index("by_story_block", ["storyId", "blockIndex"])
    .index("by_story", ["storyId"]),

  suggestions: defineTable({
    storyId: v.id("stories"),
    userId: v.id("users"),
    content: v.string(),
    attachmentUrl: v.optional(v.string()),
    attachmentFileId: v.optional(v.id("_storage")),
    parentSuggestionId: v.optional(v.id("suggestions")),
    upvotes: v.array(v.id("users")),
    createdAt: v.number(),
  })
    .index("by_story", ["storyId"])
    .index("by_parent", ["parentSuggestionId"]),

  storyIdeas: defineTable({
    title: v.string(),
    description: v.string(),
    suggestedBy: v.id("users"),
    station: v.optional(v.string()),
    upvotes: v.array(v.id("users")),
    status: v.string(),
    claimedBy: v.optional(v.id("users")),
    createdAt: v.number(),
  }).index("by_status", ["status"]),

  editHistory: defineTable({
    storyId: v.id("stories"),
    userId: v.optional(v.id("users")),
    action: v.string(),
    details: v.any(),
    createdAt: v.number(),
  })
    .index("by_story", ["storyId"])
    .index("by_story_time", ["storyId", "createdAt"]),

  soundLibrary: defineTable({
    name: v.string(),
    description: v.string(),
    source: v.string(),
    fileId: v.id("_storage"),
    type: v.string(),
    prompt: v.optional(v.string()),
    freesoundId: v.optional(v.number()),
    license: v.optional(v.string()),
    attribution: v.optional(v.string()),
    durationSeconds: v.number(),
    tags: v.array(v.string()),
    createdBy: v.id("users"),
  })
    .index("by_type", ["type"])
    .searchIndex("search_sounds", {
      searchField: "name",
      filterFields: ["type"],
    }),

  orgSettings: defineTable({
    slackWebhookUrl: v.optional(v.string()),
    slackChannelName: v.optional(v.string()),
    slackNotifyEvents: v.optional(v.array(v.string())),
    appUrl: v.optional(v.string()),
  }),
});
```

**Step 4: Run Convex codegen to validate schema**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx convex dev --once
```

Expected: Schema validates and types are generated in `convex/_generated/`.

**Step 5: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add app/convex/ app/package.json app/package-lock.json
git commit -m "feat: add Convex backend with full v5.1 schema"
```

---

## Task 4: Wire WorkOS AuthKit

**Files:**
- Create: `app/convex/auth.config.ts`
- Modify: `app/src/main.tsx` (wrap with AuthKit + Convex providers)
- Create: `app/src/pages/LoginPage.tsx`
- Modify: `app/package.json` (add WorkOS + Convex auth packages)

**Step 1: Install auth packages**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npm install @workos-inc/authkit-react @convex-dev/workos
```

**Step 2: Create Convex auth config**

Create `app/convex/auth.config.ts`:

```typescript
export default {
  providers: [
    {
      type: "customJwt" as const,
      issuer: `https://api.workos.com/`,
      algorithm: "RS256" as const,
      applicationID: process.env.WORKOS_CLIENT_ID,
      jwks: `https://api.workos.com/sso/jwks/${process.env.WORKOS_CLIENT_ID}`,
    },
    {
      type: "customJwt" as const,
      issuer: `https://api.workos.com/user_management/${process.env.WORKOS_CLIENT_ID}`,
      algorithm: "RS256" as const,
      jwks: `https://api.workos.com/sso/jwks/${process.env.WORKOS_CLIENT_ID}`,
    },
  ],
};
```

**Step 3: Wire providers in main.tsx**

Replace `app/src/main.tsx`:

```tsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { AuthKitProvider, useAuth } from "@workos-inc/authkit-react";
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithAuthKit } from "@convex-dev/workos";
import App from "./App";
import "./index.css";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <AuthKitProvider
      clientId={import.meta.env.VITE_WORKOS_CLIENT_ID as string}
      redirectUri={import.meta.env.VITE_WORKOS_REDIRECT_URI as string}
    >
      <ConvexProviderWithAuthKit client={convex} useAuth={useAuth}>
        <App />
      </ConvexProviderWithAuthKit>
    </AuthKitProvider>
  </StrictMode>
);
```

**Step 4: Create .env.local template for the app**

Create `app/.env.local.example`:

```
VITE_CONVEX_URL=https://your-deployment.convex.cloud
VITE_WORKOS_CLIENT_ID=client_your_id
VITE_WORKOS_REDIRECT_URI=http://localhost:5173/callback
```

**Step 5: Create LoginPage**

Create `app/src/pages/LoginPage.tsx`:

```tsx
import { useAuth } from "@workos-inc/authkit-react";

export default function LoginPage() {
  const { signIn } = useAuth();

  return (
    <div className="flex items-center justify-center min-h-screen bg-zinc-950">
      <div className="text-center space-y-8">
        <div>
          <h1 className="text-4xl font-bold text-white">StoryForge</h1>
          <p className="text-zinc-400 mt-2">
            AI-Powered Radio Storytelling Studio
          </p>
        </div>
        <button
          onClick={() => signIn()}
          className="px-6 py-3 bg-white text-zinc-900 font-semibold rounded-lg hover:bg-zinc-200 transition-colors"
        >
          Sign In
        </button>
      </div>
    </div>
  );
}
```

**Step 6: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add app/
git commit -m "feat: wire WorkOS AuthKit with Convex provider"
```

---

## Task 5: Set Up React Router + Page Shells

**Files:**
- Modify: `app/package.json` (add react-router)
- Modify: `app/src/App.tsx` (router setup)
- Create: `app/src/pages/DashboardPage.tsx`
- Create: `app/src/pages/NewStoryPage.tsx`
- Create: `app/src/pages/ProductionPage.tsx`
- Create: `app/src/pages/ReviewPage.tsx`
- Create: `app/src/pages/SettingsPage.tsx`
- Create: `app/src/pages/CallbackPage.tsx`
- Create: `app/src/components/layout/AppShell.tsx`
- Create: `app/src/components/layout/Sidebar.tsx`

**Step 1: Install React Router**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npm install react-router
```

**Step 2: Create the AppShell layout**

Create `app/src/components/layout/AppShell.tsx`:

```tsx
import { Outlet, Link, useLocation } from "react-router";
import { useConvexAuth } from "convex/react";
import {
  LayoutDashboard,
  PlusCircle,
  Settings,
  Radio,
} from "lucide-react";

const navItems = [
  { to: "/", icon: LayoutDashboard, label: "Story Board" },
  { to: "/story/new", icon: PlusCircle, label: "New Story" },
  { to: "/settings", icon: Settings, label: "Settings" },
];

export default function AppShell() {
  const { isAuthenticated } = useConvexAuth();
  const location = useLocation();

  if (!isAuthenticated) return null;

  return (
    <div className="flex h-screen bg-zinc-950 text-zinc-100">
      {/* Sidebar */}
      <aside className="w-64 border-r border-zinc-800 flex flex-col">
        <div className="p-4 border-b border-zinc-800">
          <Link to="/" className="flex items-center gap-2">
            <Radio className="h-6 w-6 text-blue-500" />
            <span className="text-lg font-bold">StoryForge</span>
          </Link>
        </div>
        <nav className="flex-1 p-2 space-y-1">
          {navItems.map((item) => {
            const isActive = location.pathname === item.to;
            return (
              <Link
                key={item.to}
                to={item.to}
                className={`flex items-center gap-3 px-3 py-2 rounded-lg text-sm transition-colors ${
                  isActive
                    ? "bg-zinc-800 text-white"
                    : "text-zinc-400 hover:text-white hover:bg-zinc-800/50"
                }`}
              >
                <item.icon className="h-4 w-4" />
                {item.label}
              </Link>
            );
          })}
        </nav>
      </aside>

      {/* Main content */}
      <main className="flex-1 overflow-auto">
        <Outlet />
      </main>
    </div>
  );
}
```

**Step 3: Create page shells**

Create `app/src/pages/DashboardPage.tsx`:

```tsx
export default function DashboardPage() {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Story Board</h1>
      <p className="text-zinc-400">
        Stories across all stations will appear here.
      </p>
    </div>
  );
}
```

Create `app/src/pages/NewStoryPage.tsx`:

```tsx
export default function NewStoryPage() {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">New Story</h1>
      <p className="text-zinc-400">
        Upload an interview recording to get started.
      </p>
    </div>
  );
}
```

Create `app/src/pages/ProductionPage.tsx`:

```tsx
import { useParams } from "react-router";

export default function ProductionPage() {
  const { id } = useParams();

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Production Workspace</h1>
      <p className="text-zinc-400">Story ID: {id}</p>
      <p className="text-zinc-500 mt-2">
        Waveform editor, transcript editor, and coaching panel will render here.
      </p>
    </div>
  );
}
```

Create `app/src/pages/ReviewPage.tsx`:

```tsx
import { useParams } from "react-router";

export default function ReviewPage() {
  const { id } = useParams();

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Producer Review</h1>
      <p className="text-zinc-400">Story ID: {id}</p>
      <p className="text-zinc-500 mt-2">
        Producer review interface with inline notes and approval controls.
      </p>
    </div>
  );
}
```

Create `app/src/pages/SettingsPage.tsx`:

```tsx
export default function SettingsPage() {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">Settings</h1>
      <p className="text-zinc-400">
        Team management, station config, and integrations.
      </p>
    </div>
  );
}
```

Create `app/src/pages/CallbackPage.tsx`:

```tsx
import { useEffect } from "react";
import { useNavigate } from "react-router";
import { useAuth } from "@workos-inc/authkit-react";

export default function CallbackPage() {
  const navigate = useNavigate();
  const { isLoading, user } = useAuth();

  useEffect(() => {
    if (!isLoading && user) {
      navigate("/");
    }
  }, [isLoading, user, navigate]);

  return (
    <div className="flex items-center justify-center min-h-screen bg-zinc-950 text-white">
      <p>Signing in...</p>
    </div>
  );
}
```

**Step 4: Wire up the router in App.tsx**

Replace `app/src/App.tsx`:

```tsx
import { BrowserRouter, Routes, Route } from "react-router";
import { Authenticated, Unauthenticated } from "convex/react";
import { Toaster } from "@/components/ui/sonner";
import AppShell from "@/components/layout/AppShell";
import LoginPage from "@/pages/LoginPage";
import CallbackPage from "@/pages/CallbackPage";
import DashboardPage from "@/pages/DashboardPage";
import NewStoryPage from "@/pages/NewStoryPage";
import ProductionPage from "@/pages/ProductionPage";
import ReviewPage from "@/pages/ReviewPage";
import SettingsPage from "@/pages/SettingsPage";

export default function App() {
  return (
    <BrowserRouter>
      <Authenticated>
        <Routes>
          <Route element={<AppShell />}>
            <Route path="/" element={<DashboardPage />} />
            <Route path="/story/new" element={<NewStoryPage />} />
            <Route path="/story/:id" element={<ProductionPage />} />
            <Route path="/story/:id/review" element={<ReviewPage />} />
            <Route path="/settings" element={<SettingsPage />} />
          </Route>
          <Route path="/callback" element={<CallbackPage />} />
        </Routes>
        <Toaster />
      </Authenticated>
      <Unauthenticated>
        <Routes>
          <Route path="/callback" element={<CallbackPage />} />
          <Route path="*" element={<LoginPage />} />
        </Routes>
      </Unauthenticated>
    </BrowserRouter>
  );
}
```

**Step 5: Install lucide-react for icons**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npm install lucide-react
```

**Step 6: Verify routing works**

Start the dev server and check that `/`, `/story/new`, `/settings` routes render their page shells (you'll see the unauthenticated/login view without WorkOS keys configured).

**Step 7: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add app/
git commit -m "feat: add React Router with page shells and AppShell layout"
```

---

## Task 6: Convex Queries and Mutations (Core CRUD)

**Files:**
- Create: `app/convex/stories.ts`
- Create: `app/convex/transcripts.ts`
- Create: `app/convex/notifications.ts`
- Create: `app/convex/comments.ts`
- Create: `app/convex/users.ts`
- Create: `app/convex/stations.ts`

**Step 1: Create users queries/mutations**

Create `app/convex/users.ts`:

```typescript
import { v } from "convex/values";
import { query, mutation, internalMutation } from "./_generated/server";

export const getMe = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    return await ctx.db
      .query("users")
      .withIndex("by_workos_id", (q) =>
        q.eq("workosUserId", identity.subject)
      )
      .unique();
  },
});

export const upsertFromAuth = internalMutation({
  args: {
    workosUserId: v.string(),
    name: v.string(),
    email: v.string(),
    role: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("users")
      .withIndex("by_workos_id", (q) =>
        q.eq("workosUserId", args.workosUserId)
      )
      .unique();

    if (existing) {
      await ctx.db.patch(existing._id, {
        name: args.name,
        email: args.email,
        lastActiveAt: Date.now(),
      });
      return existing._id;
    }

    return await ctx.db.insert("users", {
      workosUserId: args.workosUserId,
      name: args.name,
      email: args.email,
      role: args.role ?? "dj",
      stations: [],
      lastActiveAt: Date.now(),
    });
  },
});

export const updateLastActive = mutation({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return;

    const user = await ctx.db
      .query("users")
      .withIndex("by_workos_id", (q) =>
        q.eq("workosUserId", identity.subject)
      )
      .unique();

    if (user) {
      await ctx.db.patch(user._id, { lastActiveAt: Date.now() });
    }
  },
});
```

**Step 2: Create stations queries**

Create `app/convex/stations.ts`:

```typescript
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

export const list = query({
  handler: async (ctx) => {
    return await ctx.db.query("stations").collect();
  },
});

export const getBySlug = query({
  args: { slug: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("stations")
      .withIndex("by_slug", (q) => q.eq("slug", args.slug))
      .unique();
  },
});

export const create = mutation({
  args: {
    slug: v.string(),
    name: v.string(),
    description: v.string(),
    voiceGuide: v.string(),
    systemPrompt: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("stations", args);
  },
});
```

**Step 3: Create stories queries/mutations**

Create `app/convex/stories.ts`:

```typescript
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

export const list = query({
  handler: async (ctx) => {
    return await ctx.db.query("stories").order("desc").take(100);
  },
});

export const listByStation = query({
  args: { stationId: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("stories")
      .withIndex("by_station", (q) => q.eq("stationId", args.stationId))
      .order("desc")
      .take(100);
  },
});

export const listByStatus = query({
  args: { status: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("stories")
      .withIndex("by_status", (q) => q.eq("status", args.status))
      .order("desc")
      .take(100);
  },
});

export const get = query({
  args: { id: v.id("stories") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});

export const create = mutation({
  args: {
    title: v.string(),
    stationId: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const user = await ctx.db
      .query("users")
      .withIndex("by_workos_id", (q) =>
        q.eq("workosUserId", identity.subject)
      )
      .unique();

    if (!user) throw new Error("User not found");

    return await ctx.db.insert("stories", {
      title: args.title,
      stationId: args.stationId,
      creatorId: user._id,
      status: "transcribing",
    });
  },
});

export const updateStatus = mutation({
  args: {
    id: v.id("stories"),
    status: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, { status: args.status });
  },
});

export const updateSteering = mutation({
  args: {
    id: v.id("stories"),
    selectedAngle: v.optional(v.string()),
    themes: v.optional(v.array(v.string())),
    emotionalTone: v.optional(v.string()),
    narrativeDirection: v.optional(v.string()),
    targetLengthSeconds: v.optional(v.number()),
    format: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const { id, ...updates } = args;
    const filtered = Object.fromEntries(
      Object.entries(updates).filter(([_, v]) => v !== undefined)
    );
    await ctx.db.patch(id, filtered);
  },
});
```

**Step 4: Create transcripts queries**

Create `app/convex/transcripts.ts`:

```typescript
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

export const getByStory = query({
  args: { storyId: v.id("stories") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("transcripts")
      .withIndex("by_story", (q) => q.eq("storyId", args.storyId))
      .unique();
  },
});

export const search = query({
  args: { searchText: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("transcripts")
      .withSearchIndex("search_text", (q) =>
        q.search("searchableText", args.searchText)
      )
      .take(20);
  },
});
```

**Step 5: Create notifications queries**

Create `app/convex/notifications.ts`:

```typescript
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

export const getUnread = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    const user = await ctx.db
      .query("users")
      .withIndex("by_workos_id", (q) =>
        q.eq("workosUserId", identity.subject)
      )
      .unique();

    if (!user) return [];

    return await ctx.db
      .query("notifications")
      .withIndex("by_user_unread", (q) =>
        q.eq("userId", user._id).eq("read", false)
      )
      .order("desc")
      .take(50);
  },
});

export const markRead = mutation({
  args: { id: v.id("notifications") },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, { read: true });
  },
});
```

**Step 6: Create comments queries**

Create `app/convex/comments.ts`:

```typescript
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

export const listByStory = query({
  args: { storyId: v.id("stories") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("comments")
      .withIndex("by_story", (q) => q.eq("storyId", args.storyId))
      .order("desc")
      .take(100);
  },
});
```

**Step 7: Validate all with Convex codegen**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx convex dev --once
```

Expected: No errors. Types generated.

**Step 8: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add app/convex/
git commit -m "feat: add core Convex queries and mutations for all entities"
```

---

## Task 7: Convex Action Stubs (External APIs)

**Files:**
- Create: `app/convex/actions/deepgram.ts`
- Create: `app/convex/actions/elevenlabs.ts`
- Create: `app/convex/actions/freesound.ts`
- Create: `app/convex/actions/gradientAgent.ts`
- Create: `app/convex/actions/email.ts`
- Create: `app/convex/actions/slack.ts`

**Step 1: Create Deepgram stub**

Create `app/convex/actions/deepgram.ts`:

```typescript
"use node";
import { action } from "../_generated/server";
import { v } from "convex/values";

export const transcribe = action({
  args: { audioFileId: v.id("_storage") },
  handler: async (ctx, args) => {
    const apiKey = process.env.DEEPGRAM_API_KEY;

    if (!apiKey) {
      console.log("[STUB] Deepgram transcribe called — returning mock data");
      return {
        transcript: {
          markdown: "**Speaker 1:** This is a mock transcript for development.\n\n**Speaker 2:** It includes word-level timestamps for testing.",
          speakers: [
            { id: "speaker_1", name: "Speaker 1", color: "#4A9EFF" },
            { id: "speaker_2", name: "Speaker 2", color: "#FF6B4A" },
          ],
          durationSeconds: 120,
          wordTimestamps: [
            { word: "This", start: 0.0, end: 0.2, confidence: 0.99, speaker: "speaker_1" },
            { word: "is", start: 0.2, end: 0.3, confidence: 0.99, speaker: "speaker_1" },
            { word: "a", start: 0.3, end: 0.35, confidence: 0.99, speaker: "speaker_1" },
            { word: "mock", start: 0.35, end: 0.55, confidence: 0.99, speaker: "speaker_1" },
            { word: "transcript", start: 0.55, end: 0.9, confidence: 0.98, speaker: "speaker_1" },
          ],
          searchableText: "This is a mock transcript for development. It includes word-level timestamps for testing.",
        },
      };
    }

    // TODO: Real Deepgram API call
    // const audioUrl = await ctx.storage.getUrl(args.audioFileId);
    // const response = await fetch("https://api.deepgram.com/v1/listen?...", { ... });
    throw new Error("Real Deepgram integration not yet implemented");
  },
});
```

**Step 2: Create ElevenLabs stub**

Create `app/convex/actions/elevenlabs.ts`:

```typescript
"use node";
import { action } from "../_generated/server";
import { v } from "convex/values";

export const generateSoundEffect = action({
  args: {
    prompt: v.string(),
    durationSeconds: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const apiKey = process.env.ELEVENLABS_API_KEY;

    if (!apiKey) {
      console.log(`[STUB] ElevenLabs SFX: "${args.prompt}" (${args.durationSeconds}s)`);
      return { fileId: null, durationSeconds: args.durationSeconds ?? 10 };
    }

    throw new Error("Real ElevenLabs integration not yet implemented");
  },
});

export const generateMusic = action({
  args: {
    prompt: v.string(),
    durationSeconds: v.number(),
  },
  handler: async (ctx, args) => {
    const apiKey = process.env.ELEVENLABS_API_KEY;

    if (!apiKey) {
      console.log(`[STUB] ElevenLabs Music: "${args.prompt}" (${args.durationSeconds}s)`);
      return { fileId: null };
    }

    throw new Error("Real ElevenLabs integration not yet implemented");
  },
});
```

**Step 3: Create Freesound stub**

Create `app/convex/actions/freesound.ts`:

```typescript
"use node";
import { action } from "../_generated/server";
import { v } from "convex/values";

export const search = action({
  args: {
    query: v.string(),
    pageSize: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const apiKey = process.env.FREESOUND_API_KEY;

    if (!apiKey) {
      console.log(`[STUB] Freesound search: "${args.query}"`);
      return {
        count: 3,
        results: [
          { id: 1, name: "City Ambience", duration: 30, license: "CC0", tags: ["city", "ambient"] },
          { id: 2, name: "Rain on Roof", duration: 60, license: "CC-BY", tags: ["rain", "ambient"] },
          { id: 3, name: "Soft Piano", duration: 45, license: "CC0", tags: ["music", "piano"] },
        ],
      };
    }

    throw new Error("Real Freesound integration not yet implemented");
  },
});
```

**Step 4: Create Gradient Agent stub**

Create `app/convex/actions/gradientAgent.ts`:

```typescript
"use node";
import { action } from "../_generated/server";
import { v } from "convex/values";

export const callAgent = action({
  args: {
    agent: v.string(), // "coach" | "transcript" | "content" | "workflow"
    payload: v.any(),
  },
  handler: async (ctx, args) => {
    const agentUrl = process.env.GRADIENT_AGENT_URL;

    if (!agentUrl) {
      console.log(`[STUB] Gradient Agent "${args.agent}" called`);

      switch (args.agent) {
        case "coach":
          return {
            coaching: "I see strong story angles in this interview. The emotional peak around the midpoint could anchor your air break. Consider leading with the most vivid quote.",
          };
        case "transcript":
          return {
            storyAngles: [
              { angle: "Community change", strength: 0.9, reasoning: "Strong personal narrative" },
              { angle: "Housing crisis", strength: 0.7, reasoning: "Data-supported trend" },
            ],
            keyQuotes: [
              { text: "This is a mock quote", start: 14.32, end: 14.58, theme: "loss" },
            ],
            emotionalArc: [
              { time: 0, intensity: 0.3 },
              { time: 60, intensity: 0.7 },
              { time: 120, intensity: 0.5 },
            ],
          };
        case "content":
          return {
            airBreak: { script: "Mock air break script...", estimatedSeconds: 90 },
            podcastSegment: { script: "Mock podcast segment...", estimatedSeconds: 480 },
            socialThread: { posts: ["Mock social post 1", "Mock social post 2"] },
            webArticle: { html: "<p>Mock web article...</p>" },
            newsletterCopy: { text: "Mock newsletter copy..." },
            pressRelease: { text: "Mock press release..." },
          };
        case "workflow":
          return { action: "none", message: "No workflow action needed" };
        default:
          return { error: `Unknown agent: ${args.agent}` };
      }
    }

    // TODO: Real HTTP call to deployed Gradient ADK agent
    // const response = await fetch(`${agentUrl}/run`, {
    //   method: "POST",
    //   headers: { "Content-Type": "application/json", "Authorization": `Bearer ${process.env.DIGITALOCEAN_API_TOKEN}` },
    //   body: JSON.stringify({ prompt: JSON.stringify(args.payload) }),
    // });
    throw new Error("Real Gradient Agent integration not yet implemented");
  },
});
```

**Step 5: Create Email stub**

Create `app/convex/actions/email.ts`:

```typescript
"use node";
import { internalAction } from "../_generated/server";
import { v } from "convex/values";

export const sendNotificationEmail = internalAction({
  args: {
    to: v.string(),
    subject: v.string(),
    body: v.string(),
  },
  handler: async (ctx, args) => {
    const apiKey = process.env.RESEND_API_KEY;

    if (!apiKey) {
      console.log(`[STUB] Email to ${args.to}: "${args.subject}"`);
      return;
    }

    throw new Error("Real Resend integration not yet implemented");
  },
});
```

**Step 6: Create Slack stub**

Create `app/convex/actions/slack.ts`:

```typescript
"use node";
import { internalAction } from "../_generated/server";
import { v } from "convex/values";

export const postToSlack = internalAction({
  args: {
    message: v.string(),
    detail: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const webhookUrl = process.env.SLACK_WEBHOOK_URL;

    if (!webhookUrl) {
      console.log(`[STUB] Slack: ${args.message}`);
      return;
    }

    throw new Error("Real Slack integration not yet implemented");
  },
});
```

**Step 7: Validate with Convex**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx convex dev --once
```

**Step 8: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add app/convex/actions/
git commit -m "feat: add Convex action stubs for all external APIs"
```

---

## Task 8: Gradient ADK Agent Skeleton (Python)

**Files:**
- Create: `agents/.gradient/agent.yml`
- Create: `agents/main.py`
- Create: `agents/agents/__init__.py`
- Create: `agents/agents/coach.py`
- Create: `agents/agents/transcript.py`
- Create: `agents/agents/content.py`
- Create: `agents/agents/workflow.py`
- Create: `agents/tools/__init__.py`
- Create: `agents/requirements.txt`
- Create: `agents/.env.example`

**Step 1: Create directory structure**

```bash
mkdir -p /Users/tarikmoody/Documents/Projects/storyforge/agents/.gradient
mkdir -p /Users/tarikmoody/Documents/Projects/storyforge/agents/agents
mkdir -p /Users/tarikmoody/Documents/Projects/storyforge/agents/tools
```

**Step 2: Create agent.yml**

Create `agents/.gradient/agent.yml`:

```yaml
name: storyforge-agents
version: "1.0"
description: "StoryForge multi-agent storytelling system for public radio"
```

**Step 3: Create requirements.txt**

Create `agents/requirements.txt`:

```
langgraph>=0.2.0
langchain-core>=0.3.0
python-dotenv>=1.0.0
httpx>=0.27.0
```

**Step 4: Create agent modules**

Create `agents/agents/__init__.py`:

```python
from .coach import coach_agent
from .transcript import transcript_agent
from .content import content_agent
from .workflow import workflow_agent

__all__ = ["coach_agent", "transcript_agent", "content_agent", "workflow_agent"]
```

Create `agents/agents/coach.py`:

```python
"""CoachAgent — Storytelling mentor with RAG from station knowledge base."""

import json


async def coach_agent(input_data: dict) -> dict:
    """Process a coaching request.

    Args:
        input_data: Contains 'production_state' (current step, transcript excerpt,
                    DJ's edits) and 'query' (specific coaching question).

    Returns:
        Dict with 'coaching' text referencing specific timestamps and
        editorial reasoning.
    """
    query = input_data.get("query", "")
    production_state = input_data.get("production_state", {})
    current_step = production_state.get("step", "unknown")

    # TODO: Retrieve from station-knowledge Knowledge Base
    # TODO: Call anthropic-claude-4.5-sonnet via DO Serverless Inference

    return {
        "coaching": (
            f"[CoachAgent stub] Responding to: '{query}' "
            f"(current step: {current_step}). "
            "In production, this will provide craft guidance from "
            "This American Life, Radiolab, and Radio Milwaukee best practices."
        ),
    }
```

Create `agents/agents/transcript.py`:

```python
"""TranscriptAgent — Audio intelligence, story discovery, and analysis."""


async def transcript_agent(input_data: dict) -> dict:
    """Analyze a transcript for story angles, quotes, and emotional arc.

    Args:
        input_data: Contains 'transcript' (corrected transcript text),
                    'word_timestamps' (list of word-level timestamps).

    Returns:
        Dict with 'story_angles', 'key_quotes', 'emotional_arc',
        'filler_words'.
    """
    # TODO: Call anthropic-claude-4.5-sonnet for analysis
    # TODO: Query story-archive Knowledge Base for prior coverage

    return {
        "story_angles": [
            {
                "angle": "Community change",
                "strength": 0.9,
                "reasoning": "Strong personal narrative with clear arc",
            },
            {
                "angle": "Housing policy",
                "strength": 0.7,
                "reasoning": "Data points support systemic analysis",
            },
        ],
        "key_quotes": [],
        "emotional_arc": [],
        "filler_words": [],
    }
```

Create `agents/agents/content.py`:

```python
"""ContentAgent — Multi-format content generator with station voice switching."""


async def content_agent(input_data: dict) -> dict:
    """Generate all six content formats from a single interview.

    Args:
        input_data: Contains 'transcript', 'selected_tape' (timestamps),
                    'steering' (angle, tone, themes), 'station' (voice guide),
                    'style_profile' (DJ's writing style).

    Returns:
        Dict with 'air_break', 'podcast_segment', 'social_thread',
        'web_article', 'newsletter_copy', 'press_release'.
    """
    station = input_data.get("station", {})
    steering = input_data.get("steering", {})

    # TODO: Call anthropic-claude-4.5-sonnet with station voice and DJ style
    # TODO: Retrieve from personal-style Knowledge Base

    return {
        "air_break": {"script": "[ContentAgent stub] Air break script...", "estimated_seconds": 90},
        "podcast_segment": {"script": "[ContentAgent stub] Podcast segment...", "estimated_seconds": 480},
        "social_thread": {"posts": ["[ContentAgent stub] Social post 1"]},
        "web_article": {"html": "<p>[ContentAgent stub] Web article...</p>"},
        "newsletter_copy": {"text": "[ContentAgent stub] Newsletter copy..."},
        "press_release": {"text": "[ContentAgent stub] Press release..."},
    }
```

Create `agents/agents/workflow.py`:

```python
"""WorkflowAgent — Production manager, routing, and cross-station coordination."""


async def workflow_agent(input_data: dict) -> dict:
    """Process workflow state changes and coordination.

    Args:
        input_data: Contains 'event' (status change, submission, etc.),
                    'story' (current story state), 'org_stories' (other active stories).

    Returns:
        Dict with 'actions' (notifications to send, status changes),
        'overlaps' (cross-station overlap alerts).
    """
    event = input_data.get("event", "")

    # TODO: Implement routing logic and cross-station overlap detection

    return {
        "actions": [],
        "overlaps": [],
        "message": f"[WorkflowAgent stub] Processed event: {event}",
    }
```

**Step 5: Create the router entry point**

Create `agents/main.py`:

```python
"""StoryForge Agent Router — Gradient ADK entry point.

Dispatches requests to the appropriate specialist agent based on
the 'agent' field in the input payload.
"""

import asyncio
import json
import os
from dotenv import load_dotenv

from agents import coach_agent, transcript_agent, content_agent, workflow_agent

load_dotenv()

AGENT_MAP = {
    "coach": coach_agent,
    "transcript": transcript_agent,
    "content": content_agent,
    "workflow": workflow_agent,
}


async def route_request(payload: dict) -> dict:
    """Route an incoming request to the appropriate agent."""
    agent_name = payload.get("agent", "")
    agent_input = payload.get("input", {})

    if agent_name not in AGENT_MAP:
        return {"error": f"Unknown agent: {agent_name}. Available: {list(AGENT_MAP.keys())}"}

    agent_fn = AGENT_MAP[agent_name]
    result = await agent_fn(agent_input)
    return {"agent": agent_name, "result": result}


# For local testing
if __name__ == "__main__":
    test_payload = {
        "agent": "coach",
        "input": {
            "query": "How should I open this story?",
            "production_state": {"step": "producing"},
        },
    }
    result = asyncio.run(route_request(test_payload))
    print(json.dumps(result, indent=2))
```

Create `agents/tools/__init__.py`:

```python
# Custom tools for Gradient ADK agents will go here.
```

**Step 6: Create .env.example for agents**

Create `agents/.env.example`:

```
GRADIENT_MODEL_ACCESS_KEY=
DIGITALOCEAN_API_TOKEN=
```

**Step 7: Test locally**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/agents
python main.py
```

Expected: JSON output with CoachAgent stub response.

**Step 8: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add agents/
git commit -m "feat: add Gradient ADK agent skeleton with 4 agent stubs"
```

---

## Task 9: Root-Level Config Files

**Files:**
- Create: `.env.example`
- Modify: `.gitignore` (update for all workspaces)
- Create: `README.md`

**Step 1: Create comprehensive .env.example**

Create `.env.example` at repo root:

```bash
# ============================================
# StoryForge Environment Variables
# ============================================
# Copy this to .env and fill in your values.
# For the app, also copy relevant vars to app/.env.local

# --- Auth (Required for app to work) ---
VITE_WORKOS_CLIENT_ID=client_your_id
VITE_WORKOS_REDIRECT_URI=http://localhost:5173/callback
WORKOS_CLIENT_ID=client_your_id    # Same as above, used by Convex server-side

# --- Convex ---
VITE_CONVEX_URL=https://your-deployment.convex.cloud

# --- AI Agents (Gradient ADK) ---
GRADIENT_MODEL_ACCESS_KEY=
DIGITALOCEAN_API_TOKEN=
GRADIENT_AGENT_URL=               # Set after deploying agents

# --- External APIs (optional — stubs used when missing) ---
DEEPGRAM_API_KEY=
ELEVENLABS_API_KEY=
FREESOUND_API_KEY=
RESEND_API_KEY=
SLACK_WEBHOOK_URL=
```

**Step 2: Update .gitignore**

Update `.gitignore` to be comprehensive:

```
# Dependencies
node_modules/
.npm

# Build
dist/
build/

# Environment
.env
.env.local
.env.*.local

# OS
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/
*.swp
*.swo

# Convex
.convex/

# Python
__pycache__/
*.pyc
*.pyo
.venv/
venv/
*.egg-info/
.mypy_cache/

# Gradient ADK
agents/.gradient/config.json
```

**Step 3: Create README.md**

Create `README.md`:

```markdown
# StoryForge

AI-Powered Radio Storytelling Studio — Turn Every DJ Into a Producer.

Built for the [DigitalOcean Gradient AI Hackathon](https://digitalocean.devpost.com/).

## What Is StoryForge?

StoryForge helps public radio stations turn raw interviews into broadcast-ready, multi-platform content. A DJ uploads an interview recording and gets:

- **Text-based audio editing** — edit text, edit audio (Descript-style)
- **AI storytelling coach** — craft guidance from This American Life, Radiolab, and NPR
- **6 content formats** — air break, podcast, social, web, newsletter, press release
- **Station voice switching** — same story, different brand voices
- **Editorial workflow** — 5 approval checkpoints with producer review

## Tech Stack

| Layer | Technology |
|-------|-----------|
| Frontend | React, Vite, Tailwind CSS, shadcn/ui |
| Backend | Convex (real-time reactive database) |
| Auth | WorkOS AuthKit (orgs, RBAC, SSO-ready) |
| AI Agents | DigitalOcean Gradient ADK, LangGraph |
| LLM | Claude Sonnet 4.5 via DO Serverless Inference |
| STT | Deepgram Nova-2 (word-level timestamps) |
| Sound Design | ElevenLabs SFX/Music API, Freesound API |
| Audio Editor | Waveform Playlist v7, BBC React Transcript Editor |

## Project Structure

```
storyforge/
├── app/           # Vite + React frontend + Convex backend
│   ├── src/       # React components, pages, hooks
│   └── convex/    # Convex schema, queries, mutations, actions
├── agents/        # Python Gradient ADK agents
│   └── agents/    # CoachAgent, TranscriptAgent, ContentAgent, WorkflowAgent
└── docs/          # Design documents and plans
```

## Setup

### Prerequisites

- Node.js 18+
- Python 3.10+
- Convex account (free)
- WorkOS account (free to 1M users)

### Frontend + Backend

```bash
cd app
npm install
cp .env.local.example .env.local
# Fill in VITE_CONVEX_URL and VITE_WORKOS_CLIENT_ID

npx convex dev    # Start Convex dev server
npm run dev       # Start Vite dev server
```

### AI Agents

```bash
cd agents
pip install -r requirements.txt
cp .env.example .env
# Fill in GRADIENT_MODEL_ACCESS_KEY and DIGITALOCEAN_API_TOKEN

python main.py    # Test locally
gradient agent run  # Run via Gradient ADK
```

## License

MIT
```

**Step 4: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add .env.example .gitignore README.md
git commit -m "feat: add root config files and README"
```

---

## Task 10: Seed Data Script

**Files:**
- Create: `app/convex/seed.ts`

**Step 1: Create seed data for Radio Milwaukee's four stations**

Create `app/convex/seed.ts`:

```typescript
import { mutation } from "./_generated/server";

export const seedStations = mutation({
  handler: async (ctx) => {
    const stations = [
      {
        slug: "88nine",
        name: "88Nine Radio Milwaukee",
        description: "Milwaukee's community-powered music discovery station.",
        voiceGuide: "Warm, inclusive, eclectic. Milwaukee pride without boosterism. Conversational but informed.",
        systemPrompt: "You are writing for 88Nine Radio Milwaukee. Your tone is warm, inclusive, and eclectic. You celebrate Milwaukee's creative community with genuine pride — never boosterism. Write conversationally, as if talking to a friend who's smart and curious. Reference specific Milwaukee places, people, and culture when relevant.",
      },
      {
        slug: "hyfin",
        name: "HYFIN",
        description: "Urban alternative radio — culture, music, conversation.",
        voiceGuide: "Urban alternative. Culturally specific. Centers Black experience. Unapologetic. Contemporary language.",
        systemPrompt: "You are writing for HYFIN, Milwaukee's urban alternative station. Your voice is culturally specific, centering the Black experience. Be unapologetic and direct. Use contemporary language naturally. The audience is engaged, culturally literate, and expects authenticity.",
      },
      {
        slug: "414music",
        name: "414 Music",
        description: "Milwaukee's local music spotlight.",
        voiceGuide: "Artist-first. Technical when needed, accessible always. Lets the music speak.",
        systemPrompt: "You are writing for 414 Music, Milwaukee's local music platform. Put the artist and their work first. Be technically informed when discussing craft, but always accessible. Let the music and the musician tell the story. Milwaukee's music scene is the heartbeat.",
      },
      {
        slug: "rhythmlab",
        name: "Rhythm Lab Radio",
        description: "Curated music with global perspective.",
        voiceGuide: "Curated. Global perspective. Music-nerd energy. Deep cuts and context.",
        systemPrompt: "You are writing for Rhythm Lab Radio. Your voice is curated and knowledgeable — music-nerd energy with a global perspective. Draw connections between genres, eras, and scenes. Offer context that deepens appreciation. Deep cuts welcome.",
      },
    ];

    for (const station of stations) {
      const existing = await ctx.db
        .query("stations")
        .withIndex("by_slug", (q) => q.eq("slug", station.slug))
        .unique();

      if (!existing) {
        await ctx.db.insert("stations", station);
      }
    }

    return { seeded: stations.length };
  },
});
```

**Step 2: Validate**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx convex dev --once
```

**Step 3: Commit**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git add app/convex/seed.ts
git commit -m "feat: add seed data for Radio Milwaukee's four stations"
```

---

## Task 11: Final Verification

**Step 1: Verify the full project structure**

```bash
find /Users/tarikmoody/Documents/Projects/storyforge -type f \
  -not -path "*/node_modules/*" \
  -not -path "*/.git/*" \
  -not -path "*/_generated/*" \
  -not -name ".DS_Store" \
  | sort
```

Verify all expected files exist.

**Step 2: Verify the app builds**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx vite build
```

Expected: Build succeeds with no errors.

**Step 3: Verify Convex schema is valid**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/app
npx convex dev --once
```

Expected: Schema pushes without errors.

**Step 4: Verify Python agents work**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge/agents
python main.py
```

Expected: JSON output with mock CoachAgent response.

**Step 5: Final commit if any fixes needed**

```bash
cd /Users/tarikmoody/Documents/Projects/storyforge
git status
# If changes: git add . && git commit -m "fix: address scaffold verification issues"
```

---

## Summary

After completing all 11 tasks, you'll have:

- A running Vite + React + Tailwind + shadcn/ui frontend with 6 routes and an AppShell layout
- A Convex backend with 13 tables, full schema, core queries/mutations, and 6 action stubs
- WorkOS AuthKit wired for authentication
- A Python Gradient ADK agent skeleton with 4 specialist agents and a router
- Seed data for Radio Milwaukee's four stations
- Comprehensive documentation and configuration

Every subsequent feature (audio editor, real agent logic, sound palette, etc.) builds on this foundation.
